(in-package :cl-user)
(defpackage cl-radar.wavegen
  (:use :cl
   ;;:portaudio
   :cl-radar.util))
(in-package :cl-radar.wavegen)
(cl-syntax:use-syntax :annot)


(defconstant twopi (* 2 3.14159))

;; sine: if phi > 2*pi, -=
;; ramp: should we use 2*pi?

;; each gen func: carries current-phi and d-phi-per-sample

;; phase 0 to 2pi
(defun make-sinegen (freq-hz samples-sec &key (ampl 1.0)) ;; TODO: is this used?
  (let* ((samples-per-period (/ samples-sec (float freq-hz)))
         (phi-per-sample (* samples-per-period twopi))
         (phase (* -1 phi-per-sample))) ;; start one sample before 0

    (format t "--- ~a hz at ~a hz sample rate; ~a samples per cycle; ~a phi per sample~%"
            freq-hz samples-sec samples-per-period phi-per-sample)

    (lambda ()
      (incf phase phi-per-sample)
      (format t "-] phase now ~a~%" phase)
      (when (>= phase twopi)
        (decf phase twopi))
      (* ampl (sin phase)))))

;; ----

;; cover 0 - 2*pi in 0 - 44,100
;;   sin( t * (2 * pi * f)) for t :: 0-1?

;; TODO:
(defparameter +s-r+ 48000) ;; hz
(defparameter +f+ 100) ;; hz

;; these hold state for incremental gens (faster than thunks etc)
(defvar *amplitude* 0.5)
(defvar *phase* 0.0) ;; current posn from 0 to 2*pi

;; TODO: these both, and all instances of each, use and increment *phase*;
;;  should have them return a closure for the wrapper to call

@export
(defun sines-get-next (&optional (sample-rate +s-r+) (freq +f+))
  (let ((r (* *amplitude* (sin (* freq *phase*)))))
    (incf *phase* (* 2 pi (/ 1 sample-rate)))
    r))

;; ramp: a ramp 0.1s long is 0.1 * +s-r+ samples long
;;         and at ampl 0.1 goes from -0.05 to 0.05
@export
(defun ramp-get-next (&optional (sample-rate +s-r+) (freq +f+))
  ;; TODO: this sucks
  (let* ((ramp-period (* 8.2 (/ 1.0 freq))) ;; the 10.0 is fixup to match scope
        ;;(ramp-len-samples (* ramp-period sample-rate))
        (r (- (* *phase* (/ *amplitude* ramp-period)) (/ *amplitude* 2.0))))

    (incf *phase* (* 2 pi (/ 1 sample-rate)))
    (when (> r *amplitude*) ;; TODO: wtf
      (setf *phase* 0.0))
    r))

@export
(defun signals-fill-2ch-array (ar &key (left-sig-next-fn #'sines-get-next)
                                   (right-sig-next-fn #'sines-get-next)
                                   (left-ampl 1.0) (right-ampl 1.0))
  "call next-fn for each member of both chans of array
(2d portaudio split array, (2 1024) :float)"
  (assert (= 2 (length (array-dimensions ar))))

  (let ((last-trig-sample 0.1)
        (trig-start-i 0)
        (edges '()))
    (dotimes (i (array-dimension ar 1))
      (let ((trig-ch (coerce
                      (* left-ampl (funcall left-sig-next-fn))
                      'single-float)))
        (setf (aref ar 0 i)
              trig-ch)
        (when (and (> last-trig-sample 0.0) ;; falling edge of trig channel
                   (< trig-ch 0.0))

          (push (cons trig-start-i (- i 1)) edges) ;; add (start . end) to edgelist
          (setf trig-start-i i))
        (setf last-trig-sample trig-ch))

      (setf (aref ar 1 i)
            (coerce
             (* right-ampl (funcall right-sig-next-fn))
             'single-float)))
    (values
     ar
     (nreverse edges))))

@export
(defun sines-fill-2ch-array (ar)
  (assert (= 2 (length (array-dimensions ar))))

 ;; (format t "--- sines fill array dims: ~a~%" (array-dimensions ar))
  (loop for i from 0 below (array-dimension ar 1)
        do
           (let ((nextv (coerce (sines-get-next) 'single-float)))
             ;;(format t "next val is ~a, of type ~a.~%" nextv (type-of nextv))
             (setf (aref ar 0 i) ;; left
                   nextv)
             (setf (aref ar 1 i) ;; right
                   (* 0.1 nextv))))
  ar)

;; TODO: chans
@export
(defun sines-fill-portaudio-2ch-array (ar) ;; 1d, 2x len
  (assert (= 1 (length (array-dimensions ar))))

  (let ((n-samples (floor (/ (array-dimension ar 0) 2))))

    ;;(format t "--- sines fill pa array dims: ~a~%" n-samples)

    (loop for i from 0 below n-samples
          do
             (let ((nextv (coerce (sines-get-next) 'single-float)))
               ;;(format t "next val is ~a, of type ~a.~%" nextv (type-of nextv))
               ;;(setf (aref ar 0 i) ;; left
               ;;      nextv)
               ;;(setf (aref ar 1 i) ;; right
               ;;      (* 0.1 nextv))
               (setf (aref ar (* 2 i))
                     (* 1.5 nextv))
               (setf (aref ar (+ (* 2 i) 1))
                     (* 0.3 nextv)))))
  ar)



;;;;;;;;;;;;;;;;;;; autogenerated stuff below (o1-pro)

(defun simulate-fmcw-returns-with-carrier (targets
                              &key
                              (num-antennas 4)
                              (element-spacing 0.01d0)
                              (carrier-freq 10.100e9)        ; [Hz]
                              (bandwidth 800e6)              ; [Hz]
                              (chirp-time 1e-3)              ; [s]
                              (sample-rate 1e6)              ; [samples/s]
                              (speed-of-light 3.0d8))
  "
SIMULATE-FMCW-RETURNS computes a 2D array of complex samples representing
the received FMCW signals at each of several antennas in a linear array.

ARGUMENTS:
  - TARGETS: A list of (distance angle amplitude) for each target.
      distance -> [meters]
      angle    -> [radians] (broadside = 0.0)
      amplitude-> dimensionless scaling factor for the echo

KEY PARAMETERS:
  - NUM-ANTENNAS: Number of elements in the linear array
  - ELEMENT-SPACING: Spacing (in meters) between adjacent array elements
  - CARRIER-FREQ: Center frequency f0 of the chirp in Hz
  - BANDWIDTH: Frequency sweep range in Hz
  - CHIRP-TIME: Duration of one FMCW chirp in seconds
  - SAMPLE-RATE: Baseband sampling rate in samples/sec
  - SPEED-OF-LIGHT: Speed of wave propagation (m/s); defaults to 3e8

RETURNS:
  A 2D array of complex-double-float. Dimensions:
    (num-antennas x number-of-time-samples)

EXAMPLE CALL:
  (simulate-fmcw-returns '((100.0d0 0.0d0 1.0d0) (150.0d0 0.1d0 0.8d0))
                         :num-antennas 8
                         :element-spacing 0.075d0
                         :carrier-freq 77.0e9
                         :bandwidth 1.0e9
                         :chirp-time 5.0e-5
                         :sample-rate 2.0e6)
"
  ;; Number of complex samples in time to simulate for one full chirp
  (let* ((num-samples (round (* chirp-time sample-rate)))
         ;; Allocate a 2D array: (antenna-index, time-sample-index)
         (rx-array (make-array (list num-antennas num-samples)
                               ;;:element-type 'complex-double-float
                               :initial-element #C(0.0d0 0.0d0)))
         ;; Precompute some constants
         (dt (/ 1d0 sample-rate))       ; time step between samples
         (chirp-slope (/ bandwidth chirp-time))  ; Hz per second
         (two-pi 6.283185307179586d0)
         (lambda (/ speed-of-light carrier-freq)) ; approximate wavelength
         ;; For convenience, precompute wave number factor = (2π/λ)
         (wave-number (/ (* 2d0 pi) lambda)))

    ;; ----------------------------------------------------------------
    ;; Fill in the 2D array with the sum of returns from all targets.
    ;; ----------------------------------------------------------------
    (dotimes (n num-samples)
      (let* ((tm (* n dt))  ;; current time for this sample
             ;; instantaneous chirp frequency at time t
             ;; f(t) = f0 + chirp-slope * t
             (inst-freq (+ carrier-freq (* chirp-slope tm)))
             ;; baseband phase offset of the transmit signal so far
             ;; phase(t) = 2π ∫(from 0 to t) f(τ) dτ
             ;; = 2π [f0·t + (chirp-slope/2)·t^2]
             (tx-phase (* two-pi
                          (+ (* carrier-freq tm)
                             (* 0.5 chirp-slope tm tm)))))
        (declare (ignore inst-freq))
        (declare (ignore tx-phase))

        ;; Loop over each antenna element
        (dotimes (ant num-antennas)
          (let ((sum-of-targets 0d0))  ;; accumulate complex returns
            (dolist (tg targets)
              (destructuring-bind (distance angle amplitude) tg
                ;; Round-trip delay for the target (distance -> round-trip 2R/c)
                (let* ((delay (/ (* 2d0 distance) speed-of-light))
                       ;; The time at which this path is "observed"
                       (time-delay (- tm delay)))
                  (when (plusp time-delay)
                    ;; The instantaneous freq for the delayed signal
                    ;; (assuming same chirp slope, just delayed)
                    (let* ((inst-freq-target
                            (+ carrier-freq (* chirp-slope time-delay)))
                           ;; The transmit phase at the delayed time
                           (tx-phase-target
                            (* two-pi
                               (+ (* carrier-freq time-delay)
                                  (* 0.5 chirp-slope time-delay time-delay)))))
                      (declare (ignore inst-freq-target))
                      ;; Phase shift due to propagation angle for each antenna
                      ;; additional spatial phase = k * d_antenna
                      ;; d_antenna = ant * element-spacing * sin(angle),
                      ;; but strictly it’s the projection along the wavefront:
                      (let ((spatial-phase (* wave-number
                                              ant
                                              element-spacing
                                              (sin angle))))
                        ;; The total phase = TX-chirp-phase(delayed) + spatial
                        (let ((phase-total (+ tx-phase-target spatial-phase)))
                          (incf sum-of-targets
                                ;; amplitude * e^{j·(phase_total)}
                                (complex
                                 (* amplitude (cos phase-total))
                                 (* amplitude (sin phase-total)))))))))))
            ;; Add sum-of-targets to the baseband reference. One might
            ;; also factor out the reference chirp’s own baseband mixing
            ;; (i.e., multiply by exp(-j·tx-phase)), depending on the
            ;; modeling approach. For demonstration, we omit that step
            ;; or you can uncomment the next two lines:

            ;; (let ((ref-mix (exp #C(0d0 -1d0 * tx-phase))))
            ;;   (setf sum-of-targets (* sum-of-targets ref-mix)))

            ;; Store in the array
            (setf (aref rx-array ant n) sum-of-targets)))))

    rx-array))

;;;; without reference phased and unused vars:

(defun simulate-fmcw-returns (targets
                              &key
                              (num-antennas 4)
                              (element-spacing 0.5d0)
                              (carrier-freq 24.125e9)        ; [Hz]
                              (bandwidth 200e6)              ; [Hz]
                              (chirp-time 1e-3)              ; [s]
                              (sample-rate 2e6)              ; [samples/s]
                              (speed-of-light 3.0d8))
  "
SIMULATE-FMCW-RETURNS computes a 2D array of complex samples representing
the received FMCW signals at each of several antennas in a linear array.

ARGUMENTS:
  - TARGETS: A list of (distance angle amplitude) for each target.
      distance -> [meters]
      angle    -> [radians] (broadside = 0.0)
      amplitude-> dimensionless scaling factor for the echo

KEY PARAMETERS:
  - NUM-ANTENNAS: Number of elements in the linear array
  - ELEMENT-SPACING: Spacing (in meters) between adjacent array elements
  - CARRIER-FREQ: Center frequency f0 of the chirp in Hz
  - BANDWIDTH: Frequency sweep range in Hz
  - CHIRP-TIME: Duration of one FMCW chirp in seconds
  - SAMPLE-RATE: Baseband sampling rate in samples/sec
  - SPEED-OF-LIGHT: Speed of wave propagation (m/s); defaults to 3e8

RETURNS:
  A 2D array of complex-double-float. Dimensions:
    (num-antennas x number-of-time-samples)
"
  (let* ((num-samples (round (* chirp-time sample-rate)))
         ;; Allocate a 2D array: (antenna-index, time-sample-index)
         (rx-array (make-array (list num-antennas num-samples)
                               ;;:element-type 'complex-double-float
                               :initial-element #C(0.0d0 0.0d0)))
         ;; Precompute some constants
         (dt (/ 1d0 sample-rate))       ; time step between samples
         (chirp-slope (/ bandwidth chirp-time))  ; Hz per second
         (two-pi 6.283185307179586d0)
         (lambda (/ speed-of-light carrier-freq)) ; approximate wavelength
         (wave-number (/ (* 2d0 pi) lambda)))      ; wave number = 2π/λ

    (dotimes (n num-samples)
      (let ((tm (* n dt)))  ;; current time for this sample
        ;; Loop over each antenna element
        (dotimes (ant num-antennas)
          (let ((sum-of-targets 0d0))  ;; accumulate complex returns
            (dolist (tg targets)
              (destructuring-bind (distance angle amplitude) tg
                ;; Round-trip delay for the target (distance -> 2R/c)
                (let* ((delay (/ (* 2d0 distance) speed-of-light))
                       (time-delay (- tm delay)))
                  (when (plusp time-delay)
                    ;; The transmit phase at the delayed time
                    ;; φ_delayed(t) = 2π [f0·(t-τ) + 0.5·chirp-slope·(t-τ)^2]
                    (let* ((tx-phase-target
                             (* two-pi
                                (+ (* carrier-freq time-delay)
                                   (* 0.5 chirp-slope time-delay time-delay))))
                           ;; Additional spatial phase for each antenna
                           (spatial-phase
                             (* wave-number ant element-spacing (sin angle))))
                      (incf sum-of-targets
                            (complex
                             (* amplitude (cos (+ tx-phase-target spatial-phase)))
                             (* amplitude (sin (+ tx-phase-target spatial-phase))))))))))
            (setf (aref rx-array ant n) sum-of-targets)))))
    rx-array))
